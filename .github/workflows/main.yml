# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the master branch
on:
  push:
    branches: [ marky/minikube-actions ]
  pull_request:
    branches: [ marky/minikube-actions ]
env:
  RUN_ID: ${{github.run_id}}

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  diego:
    runs-on: ubuntu-18.04
    steps:
    - uses: actions/checkout@master
    - uses: helm/kind-action@v1.0.0-rc.1
      id: cluster-setup
      with:
        version: v0.8.1
        cluster_name: kubecf-kind
    - name: pre-load image
      run: >
        docker exec --privileged -i kubecf-kind-control-plane
        ctr --namespace=k8s.io images pull
        docker.io/cfcontainerization/cf-acceptance-tests:SLE_15_SP1-23.21-7.0.0_374.gb8e8e6af-0.0.13
    - uses: actions/setup-ruby@v1
      with:
        ruby-version: '2.6'
    - name: Setup bazel
      uses: jwlawson/actions-setup-bazel@v1.0
      with:
        bazel-version: '3.1.0'
        github-api-token: ${{ secrets.GITHUB_TOKEN }}
    - name: Install parallel
      run: |
        sudo apt install -y parallel
    - name: Get a cluster
      run: |
        kubectl cluster-info
        kubectl get pods --all-namespaces
    - name: Install cf-operator
      run: |
        kubectl create namespace cf-operator
        bazel run //dev/cf_operator:apply
    - name: Wait for cf-operator
      timeout-minutes: 5
      run: >
        parallel --verbose --retries 60 --delay 2
        kubectl wait --for=condition=Ready --timeout=600s
        --namespace=cf-operator --selector=name={1} pod
        ::: cf-operator quarks-job
    - name: Wait for CRDs
      timeout-minutes: 5
      run: >
        parallel --verbose --retries 60 --delay 2
        kubectl wait --for condition=established --timeout=600s
        :::
        crd/boshdeployments.quarks.cloudfoundry.org
        crd/quarksjobs.quarks.cloudfoundry.org
        crd/quarkssecrets.quarks.cloudfoundry.org
        crd/quarksstatefulsets.quarks.cloudfoundry.org
    - name: Configure Domain
      run: |
        node_ip=$(bazel run @kubectl//:binary -- get nodes -o json | bazel run @jq//:binary -- -r '.items[].status.addresses[] | select(.type == "InternalIP").address')
        cat > "$(bazel info workspace)/dev/kubecf/system_domain_values.yaml" <<EOT
        system_domain: $node_ip.nip.io
        sizing:
          diego_cell:
            ephemeral_disk:
              size: 300000
        testing:
          cf_acceptance_tests:
            enabled: true
          smoke_tests:
            enabled: true
          sync_integration_tests:
            enabled: true
        services:
          router:
            type: ClusterIP
            externalIPs: [$node_ip]
          ssh-proxy:
            type: ClusterIP
            externalIPs: [$node_ip]
          tcp-router:
            type: ClusterIP
            externalIPs: [$node_ip]
          properties:
            acceptance-tests:
              acceptance-tests:
                acceptance_tests:
                  ginkgo:
                    nodes: 2
                    flake_attempts: 3
        EOT
    - name: Install KubeCF
      run: |
        bazel run //dev/kubecf:apply
    - name: Wait for KubeCF
      id: wait-kubecf
      timeout-minutes: 45
      run: |
        echo Waiting for pods to exist...
        set -o xtrace
        while [[ $(                                                \
            kubectl get pod --namespace=kubecf                                 \
            --selector=quarks.cloudfoundry.org/deployment-name=kubecf          \
            --output=go-template='{{ .items | len }}'                          \
          ) -lt 1 ]]
        do sleep 10
        done
        echo Waiting for pods to be ready...
        kubectl wait --for=condition=Ready --namespace=kubecf --timeout=-1s    \
          --selector=quarks.cloudfoundry.org/deployment-name=kubecf pod
    - run: kubectl get pod --namespace=kubecf --output=wide
      if: always() && steps.wait-kubecf.outcome == 'failure'
    - name: Run Smoke Tests
      id: smoke
      run: bazel run //testing:smoke_tests | tee diego-smoke.log
    - uses: actions/upload-artifact@v2
      if: always() && steps.smoke.outcome != 'skipped'
      with:
        name: diego-smoke.log
        path: diego-smoke.log
    - run: rm -f diego-smoke.log
    - name: Run CATS
      id: cats
      run: bazel run //testing:acceptance_tests | tee diego-cats.log
    - uses: actions/upload-artifact@v2
      if: always() && steps.cats.outcome != 'skipped'
      with:
        name: diego-cats.log
        path: diego-cats.log
    - name: Run SITS
      id: steps
      run: bazel run //testing:sync_integration_tests | tee diego-sits.log
    - uses: actions/upload-artifact@v2
      if: always() && steps.sits.outcome != 'skipped'
      with:
        name: diego-sits.log
        path: diego-sits.log
    - name: Get deployment details
      if: always() && steps.cluster-setup.outcome == 'success'
      run: |
        set +o errexit
        kubectl describe pods --namespace=cf-operator >> diego-post-deploy.log
        kubectl get pods --namespace=cf-operator --output yaml >> diego-post-deploy.log
        kubectl describe pods --namespace=kubecf >> diego-post-deploy.log
        kubectl get pods --namespace=kubecf --output yaml >> diego-post-deploy.log
    - uses: actions/upload-artifact@v2
      if: always() && steps.cluster-setup.outcome == 'success'
      with:
        name: diego-post-deploy.log
        path: diego-post-deploy.log
  eirini:
    runs-on: ubuntu-18.04
    steps:
    - uses: actions/checkout@master
    - uses: helm/kind-action@v1.0.0-rc.1
      id: cluster-setup
      with:
        version: v0.8.1
        cluster_name: kubecf-kind
    - uses: actions/setup-ruby@v1
      with:
        ruby-version: '2.6'
    - name: Setup bazel
      uses: jwlawson/actions-setup-bazel@v1.0
      with:
        bazel-version: '3.1.0'
        github-api-token: ${{ secrets.GITHUB_TOKEN }}
    - name: Install parallel
      run: |
        sudo apt install -y parallel
    - name: Get a cluster
      run: |
        kubectl cluster-info
        kubectl get pods --all-namespaces
    - name: Install cf-operator
      run: |
        kubectl create namespace cf-operator
        bazel run //dev/cf_operator:apply
    - name: Wait for cf-operator
      timeout-minutes: 5
      run: >
        parallel --verbose --retries 60 --delay 2
        kubectl wait --for=condition=Ready --timeout=600s
        --namespace=cf-operator --selector=name={1} pod
        ::: cf-operator quarks-job
    - name: Wait for CRDs
      timeout-minutes: 5
      run: >
        parallel --verbose --retries 60 --delay 2
        kubectl wait --for condition=established --timeout=600s
        :::
        crd/boshdeployments.quarks.cloudfoundry.org
        crd/quarksjobs.quarks.cloudfoundry.org
        crd/quarkssecrets.quarks.cloudfoundry.org
        crd/quarksstatefulsets.quarks.cloudfoundry.org
    - name: Configure Domain
      run: |
        node_ip=$(bazel run @kubectl//:binary -- get nodes -o json | bazel run @jq//:binary -- -r '.items[].status.addresses[] | select(.type == "InternalIP").address')
        cat > "$(bazel info workspace)/dev/kubecf/system_domain_values.yaml" <<EOT
        system_domain: $node_ip.nip.io
        features:
          eirini:
            enabled: true
        testing:
          smoke_tests:
            enabled: true
        services:
          router:
            type: ClusterIP
            externalIPs: [$node_ip]
          ssh-proxy:
            type: ClusterIP
            externalIPs: [$node_ip]
          tcp-router:
            type: ClusterIP
            externalIPs: [$node_ip]
          properties:
            acceptance-tests:
              acceptance-tests:
                acceptance_tests:
                  ginkgo:
                    nodes: 2
                    flake_attempts: 3
        EOT
    - name: Install KubeCF
      run: |
        bazel run //dev/kubecf:apply
    - name: Wait for KubeCF
      timeout-minutes: 30
      run: |
        echo Waiting for pods to exist...
        while [[ $(                                                            \
            kubectl get pod --namespace=kubecf                                 \
            --selector=quarks.cloudfoundry.org/deployment-name=kubecf          \
            --output=go-template='{{ .items | len }}'                          \
          ) -lt 1 ]]
        do sleep 10
        done
        echo Waiting for pods to be ready...
        kubectl wait --for=condition=Ready --namespace=kubecf --timeout=-1s    \
          --selector=quarks.cloudfoundry.org/deployment-name=kubecf pod
    - name: Run Smoke Tests
      id: smoke
      run: bazel run //testing:smoke_tests | tee eirini-smoke.log
    - uses: actions/upload-artifact@v2
      if: always() && steps.smoke.outcome != 'skipped'
      with:
        name: eirini-smoke.log
        path: eirini-smoke.log
    - name: Get deployment details
      if: always() && steps.cluster-setup.outcome == 'success'
      run: |
        set +o errexit
        kubectl describe pods --namespace=cf-operator >> eirini-post-deploy.log
        kubectl get pods --namespace=cf-operator --output yaml >> eirini-post-deploy.log
        kubectl describe pods --namespace=kubecf >> eirini-post-deploy.log
        kubectl get pods --namespace=kubecf --output yaml >> eirini-post-deploy.log
    - uses: actions/upload-artifact@v2
      if: always() && steps.cluster-setup.outcome == 'success'
      with:
        name: eirini-post-deploy.log
        path: eirini-post-deploy.log
